#include "MBFF.hpp"
#include "Parser/Parser.hpp"
#include <fstream>


int MBFF::commonNodeCnt(NODE *n1, NODE *n2){
    int same = 0;
    for(NODE *n1n : n1->neighbor){
        for(NODE *n2n : n2->neighbor){
            if(n1n == n2n) {
                same++;
                break;
            }
        }
    }
    return same;
}

void MBFF::removeNfromMnei(NODE *n, NODE *M){
    for(int i = 0; i < M->neighbor.size(); i++){
        NODE *nei = M->neighbor[i];
        if(nei == n){
            M->neighbor[i] = M->neighbor[M->neighbor.size() - 1];
            M->neighbor.pop_back();
            break;
        }
    }
}
void MBFF::mergeff2(NODE *n, vector<NODE*> &ffheap){
    // sort by neighbor size from large to small
    struct MYCOMP {
        bool operator() (NODE* i, NODE* j) { return (i->neighbor.size() < j->neighbor.size());}
    } mycomp;

    // find max common neighbor
    NODE *max = NULL;
    int maxcomm = 0;
    for(NODE *nei : n->neighbor){
        int comm = commonNodeCnt(n, nei);
        if(comm > maxcomm) { 
            max = nei;
            maxcomm = comm;
        }
    }
    
    if(max == NULL) return;
    // cout << max->NODE_name << endl;
    // merge n1 and max to newn
    NODE *newn = new NODE;
    newn->FF_name = "FF2";
    newn->NODE_name = "FF2_" + to_string(nameidx++);
    for(NODE* pin : n->FFpin)
        newn->FFpin.emplace_back(pin);
    for(NODE* pin : max->FFpin)
        newn->FFpin.emplace_back(pin);
    Rect inter = Intersect(n->FRegion, max->FRegion);
    if(inter.intersect == false){
        cout << "mergeff2 rect error!!" << endl;
        exit(1);
    }
    newn->FRegion = inter;

    for(NODE *nei : n->neighbor){
        removeNfromMnei(n, nei);
        
        Rect ffinter = Intersect(newn->FRegion, nei->FRegion);
        if(ffinter.intersect == true){
            newn->neighbor.emplace_back(nei);
            nei->neighbor.emplace_back(newn);
        }
    }
    for(NODE *nei : max->neighbor){
        removeNfromMnei(max, nei);
        
        Rect ffinter = Intersect(newn->FRegion, nei->FRegion);
        if(ffinter.intersect == true){
            newn->neighbor.emplace_back(nei);
            nei->neighbor.emplace_back(newn);
        }
    }
    n->merged = true;
    max->merged = true;
    FLIP_FLOP_LIST[newn->NODE_name] = newn;
    ffheap.emplace_back(newn);
    push_heap(ffheap.begin(), ffheap.end(), mycomp);
}

void MBFF::mergeFF1toFF2(){
    // sort by neighbor size from large to small
    struct MYCOMP {
        bool operator() (NODE* i, NODE* j) { return (i->neighbor.size() < j->neighbor.size());}
    } mycomp;

    vector<NODE*> ffheap;
    ffheap.reserve(FLIP_FLOP_LIST.size());
    for(auto FLIP_FLOP1: FLIP_FLOP_LIST){
        ffheap.emplace_back(FLIP_FLOP1.second);
    }
    make_heap(ffheap.begin(), ffheap.end(), mycomp);

    while(ffheap.size() != 0){
        NODE *n = ffheap.front();
        pop_heap(ffheap.begin(), ffheap.end(), mycomp); 
        ffheap.pop_back(); 


        if(LIBRARY[n->FF_name]->BIT_NUMBER != 1) continue;
        if(n->neighbor.size() == 0) continue; // no neighbor
        if(n->merged) continue;

        // cout << n->NODE_name << endl;

        // NODE *nei0 = n->neighbor[0];
        // for(NODE* nei : nei0->neighbor)
        //     cout << nei->NODE_name << " ";
        // cout << endl << endl;

        
        cout << n->neighbor.size() << endl;

        mergeff2(n, ffheap);

        // for(NODE* nei : nei0->neighbor)
        //     cout << nei->NODE_name << " ";
        // cout << endl << endl;
        // break;
    }
}

// ===== pre-process =====
void MBFF::FF_Feasible_Region(){
    for(auto FLIP_FLOP: FLIP_FLOP_LIST){
        NODE *ff = FLIP_FLOP.second;
        vector<Rect> rects;
        for(NODE *pin : ff->FFpin){
            int slack = pin->pinslack;
            int maxdis = slack + ff->pos.HPWL(pin->pos);
            Rect rect;
            rect.ll.x = pin->pos.x;
            rect.ll.y = pin->pos.y - maxdis;
            rect.tr.x = pin->pos.x;
            rect.tr.y = pin->pos.y + maxdis;
            Rotate45(rect);
            rects.emplace_back(rect);
        }
        Rect inter = rects[0];
        for(size_t i = 1; i < rects.size(); i++){
            if(inter.intersect == false){
                cout << "FF_Feasible_Region rect error!!" << endl;
                exit(1);
            }
            inter = Intersect(inter, rects[i]);
        }
        ff->FRegion = inter;
    }
}    

Rect MBFF::Intersect(Rect a, Rect b){
    Rect res;

    res.ll.x = max(a.ll.x, b.ll.x);
    res.tr.x = min(a.tr.x, b.tr.x);
    res.ll.y = max(a.ll.y, b.ll.y);
    res.tr.y = min(a.tr.y, b.tr.y);
    
    if (res.ll.x <= res.tr.x && res.ll.y <= res.tr.y){
        res.intersect = true;
    }
    else{        
        res.intersect = false;
    }

    return res;
}

void MBFF::Rotate45(Rect &rect){
    POS ll = rect.ll;
    POS tr = rect.tr;
    rect.ll.x = ll.x + ll.y;
    rect.ll.y = ll.y - ll.x;
    rect.tr.x = tr.x + tr.y;
    rect.tr.y = tr.y - tr.x;
}

void MBFF::ConstructOverlapGraph(){
    vector<NODE*> fflist;
    fflist.reserve(FLIP_FLOP_LIST.size());
    for(auto FLIP_FLOP1: FLIP_FLOP_LIST){
        fflist.emplace_back(FLIP_FLOP1.second);
    }
    for(int i = 0; i < fflist.size() - 1; i++){
        NODE *ff1 = fflist[i];
        for(int j = i + 1; j < fflist.size(); j++){
            NODE *ff2 = fflist[j];
            Rect inter = Intersect(ff1->FRegion, ff2->FRegion);
            if(inter.intersect == true){
                // ff1->neighbor.insert(ff2);
                // ff2->neighbor.insert(ff1);
                ff1->neighbor.emplace_back(ff2);
                ff2->neighbor.emplace_back(ff1);
            }
        }
    }
    // for(auto FLIP_FLOP1: FLIP_FLOP_LIST){
    //     NODE *ff1 = FLIP_FLOP1.second;

    //     for(auto FLIP_FLOP2: FLIP_FLOP_LIST){
    //         NODE *ff2 = FLIP_FLOP2.second;
            
    //         if(ff1==ff2) continue;
    //         Rect inter = Intersect(ff1->FRegion, ff2->FRegion);
    //         if(inter.intersect == true){
    //             ff1->neighbor.insert(ff2);
    //             ff2->neighbor.insert(ff1);
    //         }
    //     }
    // }

    // for(auto FLIP_FLOP: FLIP_FLOP_LIST){
    //     NODE *ff = FLIP_FLOP.second;
    //     cout << ff->NODE_name << ": " ;
    //     for(NODE *nei : ff->neighbor){
    //         cout << nei->NODE_name << "("<< nei->FF_name  << ") " ;
    //     }
    //     cout << endl << endl;

    // }
}
// ===== pre-process =====

// ===== logger =====
void MBFF::PrintFF(){
    cout << "\nFF count: " << FLIP_FLOP_LIST.size() << endl;
    unordered_map<string, int> LIBcnt;
    for(auto LIB : LIBRARY){
        LIBcnt[LIB.first] = 0;
    }

    for(auto FLIP_FLOP: FLIP_FLOP_LIST){
        NODE *ff = FLIP_FLOP.second;
        if(ff->merged) continue;
        LIBcnt[ff->FF_name]++;
    }
    for(auto cnt : LIBcnt){
        cout << cnt.first << " " << cnt.second << endl;
    }
}
void MBFF::PrintLIB(){
    cout << "\nLIBRARY count: " << LIBRARY.size() << " -- ";
    for(auto LIB : LIBRARY){
        cout << LIB.first << " ";
    }
    cout << endl;
}
// ===== logger =====

// ===== Parser =====
void MBFF::Parser_ICCAD2010(string Inputstr){
    ifstream fin(Inputstr);
    Parser PS;
    string str;

    while(getline(fin, str)){        
        vector<string> tok = PS.getToken(str, " ");
        if(tok[0] == "CHIP_SIZE"){
            CHIP_SIZE_W = stoi(tok[1]);
            CHIP_SIZE_H = stoi(tok[3]);
        }
        else if(tok[0] == "GRID_SIZE"){
            GRID_SIZE.x = stoi(tok[1]);
            GRID_SIZE.y = stoi(tok[3]);
        }
        else if(tok[0] == "BIN_SIZE"){
            BIN_SIZE_BinW = stoi(tok[1]);
            BIN_SIZE_BinH = stoi(tok[3]);
        }
        else if(tok[0] == "PLACEMENT_DENSITY_CONSTRAINT"){
            PLACEMENT_DENSITY_CONSTRAINT = stoi(tok[1]);
        }
        else if(str == "[LIBRARY]"){
            Parser_ICCAD2010_LIBRARY(fin);
        }
        else if(str == "[FLIP_FLOP_LIST]"){
            Parser_ICCAD2010_FLIP_FLOP_LIST(fin);
        }
        else if(str == "[PIN_LIST]"){
            Parser_ICCAD2010_PIN_LIST(fin);
        }
        else if(str == "[NET_LIST]"){
            Parser_ICCAD2010_NET_LIST(fin);            
        }
    }


    fin.close();
}
void MBFF::Parser_ICCAD2010_LIBRARY(ifstream &fin){   
    Parser PS; 
    string str;
    while(getline(fin, str)){
        if(str == "[END LIBRARY]") break;

        vector<string> tok = PS.getToken(str, " []");
        if(tok[0] == "FLIP_FLOP"){
            FLIP_FLOP *ff = new FLIP_FLOP;
            ff->FF_name = string(tok[1]);
            LIBRARY[ff->FF_name] = ff;
            
            getline(fin, str);
            tok = PS.getToken(str, " ");
            if(tok[0] == "BIT_NUMBER"){
                ff->BIT_NUMBER = stoi(tok[1]);
            }

            getline(fin, str);
            tok = PS.getToken(str, " ");
            if(tok[0] == "POWER_CONSUMPTION"){
                ff->POWER_CONSUMPTION = stoi(tok[1]);
            }

            getline(fin, str);
            tok = PS.getToken(str, " ");
            if(tok[0] == "AREA"){
                ff->POWER_CONSUMPTION = stoi(tok[1]);
            }
        }
    }
}
void MBFF::Parser_ICCAD2010_FLIP_FLOP_LIST(ifstream &fin){
    Parser PS;
    string str;
    while(getline(fin, str)){
        if(str == "[END FLIP_FLOP_LIST]") break;
        
        vector<string> tok = PS.getToken(str, " (,)");
        NODE *node = new NODE;
        node->FF_name = string(tok[0]);
        node->NODE_name = string(tok[1]);
        node->pos.x = stoi(tok[2]);
        node->pos.y = stoi(tok[3]);
        FLIP_FLOP_LIST[node->NODE_name] = node;
    }
}
void MBFF::Parser_ICCAD2010_PIN_LIST(ifstream &fin){
    Parser PS;
    string str;
    while(getline(fin, str)){
        if(str == "[END PIN_LIST]") break;
        
        vector<string> tok = PS.getToken(str, " (,)");
        NODE *node = new NODE;
        node->FF_name = string(tok[0]);
        node->NODE_name = string(tok[1]);
        node->pos.x = stoi(tok[2]);
        node->pos.y = stoi(tok[3]);
        PIN_LIST[node->NODE_name] = node;
    }
}
void MBFF::Parser_ICCAD2010_NET_LIST(ifstream &fin){
    Parser PS;
    string str;
    while(getline(fin, str)){
        if(str == "[END NET_LIST]") break;
        
        vector<string> tok = PS.getToken(str, " ");
        string pin_name = tok[0];
        string ff_name = tok[1];
        int slack = stoi(tok[2]);

        NODE *pin = PIN_LIST[pin_name];
        pin->pinslack = slack;
        NODE *ff = FLIP_FLOP_LIST[ff_name];
        ff->FFpin.emplace_back(pin);
    }
}
// ===== Parser =====